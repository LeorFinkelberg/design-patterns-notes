Паттерны делятся на [[Список литературы#^04ae42]]<c. 27>:
- порождающие,
- структурные
- и поведенческие.

Порождающие связны с процессом создания объектов. Вторые имеют отношение к композиции объектов и классов. Паттерны поведения характеризуют то, как классы или объекты взаимодействуют.

Объекты создаются посредством создания _экземпляра класса_. Говорят, что объект является экземпляром класса. 

Примесью (mixin class) называется класс, назначение которого -- предоставить дополнительный интерфейс или функциональность другим классам. Он отчасти похож на абстрактные классы в том смысле, что не предполагает непосредственного создания экземпляров. Для работы с примесями необходимо _множественное наследование_.

Не объявляйте переменные как экземпляры конкретных классов. Вместо этого придерживайтесь интерфейса, определенного абстрактного класса.

 _Наследование_ класса определяется статически на этапе _компиляции_, его проще использовать, так как оно напрямую поддержано языком программирования. _Композиция_ объектов определяется динамически _во время выполнения_ за счет того, что объекты получают ссылки на другие объекты. Композиция требует, чтобы объекты соблюдали интерфейсы друг друга. Для этого, в свою очередь, требуется тщательно проектировать интерфейсы, чтобы один объект можно было использовать вместе с широким спектором других. Поскольку доступ к объектам осуществляется только через их интерфейсы, инкапсуляция не нарушается. Во время выполнения программы любой объект можно заменить другим, лишь бы он имел тот же тип. Более того, поскольку реализация объекта пишется прежде всего в категориях его интерфейсов, то зависимость от реализации резко снижается [[Список литературы#^04ae42]]<c. 40>.

==NB! Предпочитайте композицию наследованию класса [[Список литературы#^04ae42]]<c. 40> ==

Перечень основных паттернов проектирования [[Список литературы#^04ae42]]<c. 24>:
- Abstract Factory (абстрактная фабрика): предоставляет интерфейс для создания семейств связанных между собой или зависимых объектов без указания их конкретных классов.
- Adapter (адаптер): преобразует интерфейс класса в другой интерфейс, ожидаемый клиентами. Обеспечивает совместную работу классов, которая была бы невозможна без данного паттерна из-за несовместимости интерфейсов.
- Bridge (мост): отделяет абстракцию от реализации, чтобы их можно было изменять независимо друг от друга.
- Builder (строитель): отделяет конструирование сложного объекта от его представления, чтобы один процесс конструирования мог использоваться для создания различных представлений.
- Chain of Responsibility (цепочка обязанностей): можно избежать формирования жесткой связи между отправителем запроса и его получателем, для чего возможность обработки запроса предоставляется несколькими объектами. Объекты-получатели объединяются в цепочку, и запрос передается по цепочке, пока не будет обработан каким-либо объектом.
- Command (команда): инкапсулирует запрос в виде объекта, позволяя тем самым параметризовывать клиентов по типу запроса, ставить запросы в очередь, протоколировать их и поддерживать отмену выполнения операций.
- Composite (компоновщик): группирует объекты в _древовидные структуры_ для представления иерархий типа "часть -- целое". Позволяя клиентам работать с единичными объектами так же, как с группами объектов.
- Decorator (декоратор): динамически наделяет объект новыми обязанностями. Декораторы применяются для расширения существующей функциональности и являются гибкой альтернативой порождению подклассов.
- Facade (фасад): предоставляет унифицированный интерфейс к набору интерфейсов в некоторой подсистеме. Определяет интерфейс более высокого уровня, облегчающий работу с подсистемой.
- Factory Method (фабричный метод): определяет интерфейс для создания объектов, позволяя подклассам решить, экземпляр какого класса следует создать. Позволяет классу передать ответственность за создание экземпляра в подклассы.
- Flyweight (приспособленец): применяет механизм совместного использования для эффективной поддержки большого числа мелких объектов.
- Intepreter (интерпретатор): для заданного языка определяет представление его грамматики вместе с интерпретатором, который использует представление для интерпретации предложений языка.
- Iterator (итератор): дает возможность последовательно обойти все элементы составного объекта, не раскрывая его внутренного представления.
- Mediator (посредник): определяет объект, в котором инкапсулирована информация о взаимодействии объектов из некоторого множества. Способствует ослаблению связей между объектами, позволяя им работать без явных ссылок друг на друга. Это, в свою очередь, дает возможность независимо изменять схему взаимодействия.
- Memento (хранитель): позволяет без нарушения инкапсуляции получать и сохранять во внешней памяти внутреннее состояние объекта, чтобы позже объект можно было восстановить в точно таком же состоянии.
- Observer (наблюдатель): определяет между объектами зависимость типа "один-ко-многим", так что при изменении состояния одного объекта все зависящие от него получают уведомления и автоматически обновляются.
- Prototype (прототип): описывает виды создаваемых объектов с помощью прототипа и создает новые объекты путем его копирования.
- Proxy (заместитель): подменяет другой объект для контроля доступа к нему.
- Singleton (одиночка): гарантирует, что некоторый класс может существовать только в одном экземпляре, и предоставляет глобальную точку доступа к нему.
- State (состояние): позволяет объекту изменять свое поведение при модификации внутреннего состояния. При этом все выглядит так, словно поменялся класс объекта.
- Strategy (стратегия): определяет семейство алгоритмов, инкапсулируя их все и позволяя подставлять один вместо другого. Позволяет менять алгоритм независимо от клиента, который им пользуется.
- Template Method (шаблонный метод): определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Позволяет подклассам переопределять отдельные шаги алгоритма, не меняя его общей структуры.
- Vistor (посетитель): представляет операцию, которую надо выполнить над элементами объектной структуры. Позволяет определить новую операцию без изменения классов элементов, к которым он применяется.